# 기술 스택

## 개요

이 문서는 턴제 전략 게임에 권장되는 기술 스택을 확장성, 개발자 경험, 프로덕션 준비성에 초점을 맞춰 정리합니다.

## 프론트엔드 스택

### 핵심 프레임워크: React
- **버전**: React 18+ (Concurrent 기능 포함)
- **선택 이유**:
  - 방대한 생태계와 커뮤니티 지원
  - React 18 Concurrent 렌더링의 우수한 성능
  - 강력한 TypeScript 통합
  - 성숙한 툴링과 개발 경험
  - 게임 UI 요소의 컴포넌트 재사용성

### 빌드 도구: Vite
- **선택 이유**:
  - HMR이 탑재된 매우 빠른 개발 서버
  - 최적화된 프로덕션 빌드
  - Native ESM 지원
  - 기본 제공되는 우수한 TypeScript 지원
  - 현대적이고 활발하게 유지보수되는 프로젝트

### 언어: TypeScript
- **버전**: TypeScript 5+
- **장점**:
  - 복잡한 게임 상태에 대한 타입 안전성
  - 향상된 IDE 지원과 자동완성
  - 프로젝트 성장에 따른 손쉬운 리팩터링
  - 컴파일 타임 오류 감지
  - 타입을 통한 자기 문서화 코드

### 상태 관리

#### 옵션 1: Zustand (권장)
```typescript
// 경량, 단순, 고성능
// 게임 상태 관리에 최적
```
- **장점**: 단순한 API, 최소한의 보일러플레이트, 우수한 성능
- **단점**: Redux보다 덜 성숙한 생태계

#### 옵션 2: Redux Toolkit
- **장점**: 성숙한 생태계, 우수한 DevTools, 잘 문서화됨
- **단점**: 더 많은 보일러플레이트, 가파른 학습 곡선

**권장**: 단순성을 위해 Zustand로 시작, 복잡한 비동기 로직이 필요한 경우에만 Redux Toolkit으로 마이그레이션

### UI 컴포넌트 라이브러리

#### 옵션 1: Headless UI + Tailwind CSS (권장)
- 접근성 높은 컴포넌트를 위한 Headless UI
- 유틸리티 우선 스타일링을 위한 Tailwind CSS
- 게임 미적 감각을 위한 완전한 디자인 제어권

#### 옵션 2: shadcn/ui
- Radix UI 프리미티브를 사용한 미리 만들어진 컴포넌트
- 커스터마이징 가능하고 접근성 높음
- 빠른 프로토타이핑에 적합

### 게임 렌더링

#### 2D 그리드 기반 게임의 경우:
- **Canvas API** 또는 **PixiJS** - 복잡한 애니메이션
- **CSS Grid + Flexbox** - 단순한 보드 레이아웃
- **Framer Motion** - 부드러운 UI 애니메이션

#### 고려 사항:
- 게임에 시각 효과가 많은 경우: PixiJS
- 게임이 주로 UI 중심인 경우: CSS 기반 렌더링
- 하이브리드 접근법이 대체로 최선

### 라우팅: React Router v6
- SPA를 위한 클라이언트 사이드 라우팅
- 라우트: `/`, `/game/:gameId`, `/profile`, `/leaderboard` 등

## 백엔드 스택: Supabase

### 핵심 서비스

#### 1. 데이터베이스: PostgreSQL
- 내장 기능이 포함된 **Supabase Postgres**
- 자동 API 생성
- 복잡한 쿼리를 위한 완전한 SQL 기능

#### 2. 인증
- 다양한 제공자를 지원하는 **Supabase Auth**:
  - 이메일/비밀번호
  - 매직 링크
  - OAuth (Google, GitHub 등)
- 데이터 보호를 위한 행 수준 보안(RLS)

#### 3. 실시간 구독
- 게임 상태 업데이트를 위한 **Supabase Realtime**
- 게임 테이블 변경 사항 구독
- 턴 완료 시 푸시 알림

#### 4. 스토리지
- **Supabase Storage** 활용:
  - 사용자 아바타
  - 게임 에셋 (필요 시)
  - 리플레이 데이터 (향후 기능)

#### 5. Edge Functions (선택)
- **Supabase Edge Functions** (Deno) 활용:
  - 복잡한 게임 로직 검증
  - AI 상대 수
  - 매치메이킹 알고리즘
  - 예약 작업 (예: 방치된 게임 정리)

### 데이터베이스 설계 원칙
- 일관성을 위한 데이터 정규화
- 유연한 게임 상태 저장을 위한 JSONB 활용
- 성능을 위한 적절한 인덱스 구현
- 게임 로직 강제를 위한 데이터베이스 트리거 사용
- 보안을 위한 RLS 정책

## AI 아키텍처

### AI 상대 구현

#### 옵션 1: 클라이언트 사이드 AI (MVP 권장)
```typescript
// AI가 브라우저에서 실행, 서버 비용 없음
// 단순~중간 복잡도에 적합
```
- **장점**: 서버 비용 없음, 즉시 응답, 오프라인 가능
- **단점**: 브라우저 성능의 제약, 코드가 사용자에게 노출됨

#### 옵션 2: 서버 사이드 AI (Supabase Edge Functions)
```typescript
// AI가 Supabase Edge Functions에서 실행
// 복잡한 AI 로직에 더 적합
```
- **장점**: 더 강력함, AI 로직 은닉, 외부 API 활용 가능
- **단점**: 비용 발생, 지연 시간, 복잡성

#### 옵션 3: 하이브리드 접근법
- 단순 AI는 클라이언트에서
- 고급 AI는 서버에서
- 플레이어가 난이도 선택 (AI 실행 위치에 영향)

**권장**: 클라이언트 사이드 AI로 시작, 필요 시 어려운 난이도는 서버로 이전

### 고려할 AI 알고리즘
1. **알파-베타 가지치기를 적용한 미니맥스** (고전 게임 AI)
2. **몬테카를로 트리 탐색 (MCTS)** (더 유연함, 복잡한 게임에 적합)
3. **규칙 기반 시스템** (쉬운 난이도)
4. **하이브리드 접근법** (규칙 + 탐색 알고리즘)

## 비동기 턴 관리

### 아키텍처 패턴
```
플레이어 A가 수를 둠 →
  데이터베이스 업데이트 →
    알림 트리거 →
      플레이어 B가 업데이트 수신 →
        플레이어 B가 수를 둠 (준비됐을 때)
```

### 핵심 기술 구성 요소

#### 1. 게임 상태 저장
- PostgreSQL에 완전한 게임 상태 저장
- 각 턴마다 새 행 생성 (기록/리플레이용)
- 빠른 접근을 위한 현재 상태 비정규화

#### 2. 턴 알림
- 온라인 플레이어를 위한 Supabase Realtime 즉시 업데이트
- 오프라인 플레이어를 위한 이메일 알림
- 푸시 알림 (향후: PWA 지원)

#### 3. 낙관적 UI 업데이트
- 클라이언트에서 즉시 수 표시
- 서버에서 검증
- 검증 실패 시 롤백

#### 4. 턴 타임아웃 처리
- 방치된 게임을 표시하는 데이터베이스 트리거
- 정리를 위한 크론 작업 (Edge Functions 경유)
- 게임 모드별 설정 가능한 타임아웃

## 개발 도구

### 필수 도구
- **pnpm** 또는 **npm** - 패키지 관리
- **ESLint** - 코드 린팅
- **Prettier** - 코드 포매팅
- **Husky** - Git 훅
- **lint-staged** - 커밋 전 검사

### 테스팅
- **Vitest** - 단위 테스팅 (빠름, Vite 네이티브)
- **React Testing Library** - 컴포넌트 테스팅
- **Playwright** 또는 **Cypress** - E2E 테스팅
- **MSW** - API 모킹

### 개발 워크플로우
- **GitHub** - 버전 관리
- **GitHub Actions** - CI/CD
- **Vercel** 또는 **Netlify** - 프론트엔드 호스팅
- **Supabase CLI** - 데이터베이스 마이그레이션 및 로컬 개발

## 성능 최적화

### 프론트엔드 최적화
- 라우트별 코드 분할
- 게임 컴포넌트의 지연 로딩
- 비싼 계산의 메모이제이션
- 긴 목록의 가상 스크롤 (리더보드, 기록)
- 오프라인 기능을 위한 Service Workers (PWA)

### 백엔드 최적화
- 자주 쿼리되는 필드에 데이터베이스 인덱스
- 커넥션 풀링 (Supabase가 처리)
- 자주 접근되는 데이터 캐싱
- SQL 쿼리 최적화 (EXPLAIN ANALYZE 활용)

## 보안 고려 사항

### 프론트엔드 보안
- 클라이언트 입력 검증 (UX용)
- 클라이언트 사이드 게임 상태 절대 신뢰 금지
- 모든 사용자 입력 살균 처리
- HTTPS만 사용
- 속도 제한 구현

### 백엔드 보안
- 모든 테이블에 RLS(행 수준 보안) 정책
- 서버 사이드 수 검증
- SQL 인젝션 방지 (파라미터화된 쿼리 사용)
- API 호출 속도 제한
- 의심스러운 활동에 대한 감사 로깅

### 게임 특화 보안
- 모든 수를 서버 사이드에서 검증
- 수 조작 방지
- 치팅 감지 및 방지
- 수 제출 속도 제한
- 봇 방지 수단 구현

## 모니터링 및 분석

### 오류 추적
- **Sentry** - 프론트엔드 및 백엔드 오류 추적
- 데이터베이스 오류를 위한 Supabase 로그

### 분석
- **PostHog** 또는 **Plausible** - 개인정보 친화적 분석
- 추적 항목: 게임 완료율, 평균 게임 시간, 기능 사용량
- 맞춤 분석을 위한 Supabase 데이터베이스 쿼리

### 성능 모니터링
- **Web Vitals** - 핵심 웹 지표 추적
- GitHub Actions의 Lighthouse CI
- 실제 사용자 모니터링 (RUM)

## 비용 예측 (Supabase)

### 무료 티어 한도
- 500MB 데이터베이스 공간
- 2GB 대역폭
- 월간 활성 사용자 50,000명
- MVP 및 초기 테스팅에 충분

### 확장 고려 사항
- 데이터베이스 크기 증가 모니터링
- 대역폭 절감을 위한 쿼리 최적화
- 오래된 게임 아카이브 고려
- 한도에 근접할 때 유료 티어 계획 수립

## 기술 결정 매트릭스

| 구성 요소 | 1순위 선택 | 대안 | 선택 이유 |
|-----------|-----------|------|-----------|
| 프론트엔드 프레임워크 | React 18 | Vue 3 | 생태계, TypeScript 지원 |
| 빌드 도구 | Vite | Next.js | 속도, SPA 단순성 |
| 상태 관리 | Zustand | Redux Toolkit | 단순성 vs 기능 |
| 스타일링 | Tailwind CSS | CSS Modules | 빠른 개발 |
| 백엔드 | Supabase | Firebase | PostgreSQL, 더 나은 가격 |
| AI 실행 위치 | 클라이언트 사이드 | Edge Functions | 비용 vs 성능 |
| 테스팅 | Vitest + RTL | Jest | Vite 통합 |
| 호스팅 | Vercel | Netlify | 성능, 개발자 경험 |

## 최종 권장 기술 스택

```
프론트엔드:
├── React 18 + TypeScript
├── Vite
├── Zustand (상태 관리)
├── React Router v6
├── Tailwind CSS + Headless UI
├── Framer Motion (애니메이션)
└── Supabase JS Client

백엔드:
├── Supabase PostgreSQL
├── Supabase Auth
├── Supabase Realtime
├── Supabase Storage
└── Supabase Edge Functions (AI용)

개발 도구:
├── pnpm
├── ESLint + Prettier
├── Vitest + React Testing Library
├── Playwright (E2E)
└── GitHub Actions (CI/CD)

배포:
├── Vercel (프론트엔드)
└── Supabase (백엔드)
```

## 다음 단계

1. 선택한 기술 스택으로 프로젝트 초기화
2. 개발 환경 설정
3. Supabase 프로젝트 구성
4. 기본 프로젝트 구조 생성
5. CI/CD 파이프라인 설정
6. 핵심 기능 구현 시작
