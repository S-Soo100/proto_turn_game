# 게임 디자인 고려사항

## 개요

이 문서는 퍼즐/보드게임 스타일의 턴제 전략 게임을 만들기 위한 핵심 디자인 고려사항을 정리합니다. 세부 메커니즘이 아직 확정되지 않았으므로, 디자인 결정을 위한 프레임워크를 제공합니다.

## 핵심 게임플레이 기둥

### 1. 턴제 전략의 기본

#### 좋은 턴제 전략의 조건
- **명확한 정보**: 플레이어는 결정에 필요한 모든 정보를 가져야 한다
- **의미 있는 선택**: 매 턴이 흥미로운 결정을 제시해야 한다
- **전략적 깊이**: 단순한 규칙, 복잡한 결과
- **실력 표현**: 실력 있는 플레이어가 일관되게 이겨야 한다
- **합리적인 사고 시간**: 턴에 몇 시간씩 계산이 필요해서는 안 된다

#### 턴 구조 패턴
```
클래식 턴:
  플레이어 A → 플레이어 B → 플레이어 A → 플레이어 B

동시 턴:
  두 플레이어 모두 계획 → 동시에 공개

인터럽트가 있는 교대 방식:
  플레이어 A → 플레이어 B가 반응 → 플레이어 A 계속

순차적 행동:
  플레이어 A (행동 1) → 플레이어 B (행동 1) →
  플레이어 A (행동 2) → 플레이어 B (행동 2)
```

**권장**: 단순성을 위해 클래식 교대 턴으로 시작

### 2. 퍼즐/보드게임 요소

#### 클래식 퍼즐 요소
- **공간적 추론**: 위치와 배치가 중요함
- **패턴 인식**: 승리 구성 파악
- **자원 관리**: 제한된 수/기물
- **연쇄 효과**: 하나의 수가 여러 결과를 유발
- **최적화**: "최선의" 해결책 찾기

#### 클래식 보드게임 요소
- **영역 장악**: 핵심 위치 점령
- **기물 차별화**: 고유 능력을 가진 다양한 기물
- **포획 메커니즘**: 상대 기물 제거
- **이동 규칙**: 그리드 기반 또는 영역 기반 이동
- **승리 조건**: 왕 잡기, 목표 달성, 최다 점수 등

#### 하이브리드 접근법
퍼즐과 보드게임 요소를 결합하는 것을 고려:
- 보드게임 기반 (기물, 보드, 턴)
- 퍼즐형 승리 조건 (패턴 생성, 챌린지 해결)
- 두 장르의 전략적 깊이

## 게임 상태 설계

### 필수 상태 구성 요소

#### 1. 보드/그리드
```typescript
// 보드 상태 구조 예시
interface BoardState {
  dimensions: { width: number; height: number };
  cells: Cell[][];
  pieces: Piece[];
}
```

**고려 사항**:
- 고정 크기 또는 동적?
- 정사각형 그리드, 육각형 그리드, 또는 불규칙한 형태?
- 빈 칸, 장애물, 특수 타일?
- 절차적 생성 또는 고정?

#### 2. 기물/유닛
```typescript
interface Piece {
  id: string;
  type: PieceType;
  owner: PlayerID;
  position: Position;
  properties?: {
    movementRange?: number;
    attackRange?: number;
    health?: number;
    // 게임 특화 속성
  };
}
```

**고려 사항**:
- 기물 타입의 수는?
- 기물이 고유하거나 동일한가?
- 기물에 스탯이나 능력이 있는가?
- 기물이 레벨업하거나 변신할 수 있는가?

#### 3. 플레이어 자원
```typescript
interface PlayerState {
  id: string;
  resources?: {
    actions?: number;      // 턴당 행동 횟수
    energy?: number;       // 자원 포인트
    cards?: Card[];        // 패의 카드들
    // 게임 특화 자원
  };
  score?: number;
}
```

**고려 사항**:
- 플레이어가 관리하는 자원은?
- 자원은 어떻게 생성/소비되는가?
- 자원이 공유되는가, 각 플레이어별로 있는가?

#### 4. 턴 메커니즘
```typescript
interface TurnState {
  currentPlayer: PlayerID;
  turnNumber: number;
  phase?: TurnPhase;          // 턴에 여러 단계가 있는 경우
  timeLimit?: number;          // 선택적 턴 타이머
  actionsRemaining?: number;
}
```

### 상태 검증

온라인 플레이에서 치팅 방지를 위해 필수:

```typescript
// 검증 구조 예시
interface MoveValidation {
  isLegalMove(state: GameState, move: Move): boolean;
  getValidMoves(state: GameState, playerId: PlayerID): Move[];
  applyMove(state: GameState, move: Move): GameState;
  checkWinCondition(state: GameState): WinResult | null;
}
```

**반드시 검증할 항목**:
- 플레이어의 턴인가?
- 현재 상태에서 합법적인 수인가?
- 자원이 충분한가?
- 게임 규칙을 따르는 수인가?

## 싱글플레이어 vs AI 설계

### AI 난이도 단계

#### 1. 쉬움 (초보자 친화적)
- **전략**: "좋은" 수에 약간의 편향을 둔 무작위 유효 수
- **목적**: 신규 플레이어가 메커니즘을 배우고 자신감을 쌓을 수 있게
- **구현**: 단순한 가중 무작위 선택
```typescript
// 의사코드
moves = getValidMoves(state);
weights = moves.map(move => basicHeuristic(move));
selectedMove = weightedRandom(moves, weights);
```

#### 2. 보통 (도전적)
- **전략**: 1-2수 선행 탐색, 단순 평가 함수
- **목적**: 좌절 없이 도전감 제공
- **구현**: 제한된 깊이의 미니맥스 또는 탐욕적 최선 우선 탐색
```typescript
// 미니맥스 깊이 2
function minimax(state, depth = 2) {
  // 2수 앞의 게임 상태 평가
}
```

#### 3. 어려움 (전문가)
- **전략**: 깊은 탐색, 복잡한 평가, 패턴 인식
- **목적**: 숙련된 플레이어에게 도전감 제공
- **구현**: 알파-베타 가지치기를 적용한 완전한 미니맥스 또는 MCTS
```typescript
// 더 깊은 탐색의 알파-베타 가지치기
function alphabeta(state, depth = 4, alpha, beta) {
  // 나쁜 분기 가지치기, 더 깊게 탐색
}
```

#### 4. 적응형 AI (고급 기능)
- **전략**: 플레이어 패턴을 학습하는 AI
- **목적**: 개인화된 도전
- **구현**: 플레이어 성향 추적, 전략 조정
- **참고**: 복잡함, 출시 후로 연기

### AI 성격/플레이스타일

AI 상대에게 구분되는 플레이스타일을 부여하는 것을 고려:
- **공격형**: 공세적인 수를 선호
- **수비형**: 안전을 우선시
- **균형형**: 전략의 혼합
- **예측 불가형**: 가끔 이례적인 수를 둠

이로 인해 AI가 더 인간적으로 느껴지고 흥미로워진다.

### 비동기 플레이에서의 AI 고려사항

AI의 수가 즉각적이므로:
- 현실감을 위한 인위적인 지연 추가? (예: 1-5초)
- 플레이어가 AI 수를 "빨리 넘기기" 허용
- AI 턴임을 명확하게 표시

## 비동기 PvP 설계

### 턴 알림 시스템

#### 언제 플레이어에게 알릴 것인가?
1. **상대가 수를 뒀을 때** (필수)
2. **게임 타임아웃 임박** (경고)
3. **게임 완료** (결과)
4. **상대와 매칭됐을 때** (선택)

#### 알림 채널
- **앱 내**: 브라우저 열려 있을 때 실시간 업데이트
- **이메일**: 비활성 플레이어에게
- **푸시 알림**: PWA 구현 시
- **브라우저 알림**: 플레이어가 권한 허용 시

### 턴 타이머 옵션

#### 옵션 1: 턴별 타이머
```
각 턴: 최대 24시간
초과 시: 자동 기권 또는 무작위 수
```
**장점**: 게임이 무기한 중단되지 않음
**단점**: 캐주얼 플레이어에게 급하게 느껴질 수 있음

#### 옵션 2: 총 시간 은행
```
각 플레이어: 총 7일 시간 예산
모든 턴에 걸쳐 필요에 따라 사용
```
**장점**: 플레이어에게 유연성 제공
**단점**: 구현이 더 복잡함

#### 옵션 3: 유연한 타이머
```
빠른 게임: 턴당 1시간
표준: 턴당 24시간
통신 게임: 턴당 7일
```
**장점**: 플레이어가 자신의 속도 선택
**단점**: 매치메이킹 복잡성

**권장**: 고정된 24시간 턴 타이머로 시작, 이후 옵션 추가

### 매치메이킹 고려사항

#### 매치메이킹 기준
1. **실력 기반**: ELO 또는 유사 레이팅
2. **시간 선호도**: 빠른 플레이어 vs 느린 플레이어
3. **게임 모드**: 랭크 vs 일반
4. **활동성**: 활성 vs 비활성 플레이어

#### 큐 시스템
```typescript
interface MatchmakingQueue {
  playerId: string;
  rating: number;
  preferredPace: 'quick' | 'standard' | 'slow';
  queuedAt: timestamp;
}

// 유사한 레이팅과 속도 선호도를 가진 플레이어 매칭
function findMatch(queue: MatchmakingQueue[]) {
  // 레이팅 범위 내에서 최선의 매치 찾기
  // 대기 시간이 길어지면 탐색 범위 확장
}
```

### 동시 게임

**플레이어가 여러 게임을 동시에 플레이할 수 있어야 하는가?**

**장점**:
- 더 높은 참여도
- 대기 시간 감소
- 비동기 게임에서 일반적 (chess.com은 100개 이상 허용)

**단점**:
- 압도적으로 느껴질 수 있음
- 게임당 집중도 감소 가능

**권장**:
- 무료 계정: 동시 3게임
- 프리미엄 (수익화 시): 10게임 이상
- 개인 한도 설정 옵션

## 승리 조건

### 보드게임의 일반적인 승리 조건

1. **섬멸**: 상대의 모든 기물 포획
2. **왕 포획**: 특정 기물 포획 (체스)
3. **영역**: 가장 많은 공간 장악
4. **목표 달성**: 기물을 목표 위치로 이동
5. **점수 임계값**: 먼저 X점에 도달
6. **시간 기반**: 시간 종료 시 가장 많은 점수
7. **퍼즐 완성**: 특정 패턴/구성 생성

### 복수의 승리 조건?

승리로 가는 여러 경로를 갖는 것을 고려:
- **주요**: 가장 직접적인 승리 조건
- **대안**: 주요가 막혔을 때의 대체
- **무승부 해결**: 동점 처리 방법

**예시**:
```
승리 방법: 상대의 모든 기물 제거
또는: 3턴 동안 보드의 75% 장악
무승부 해결: 남은 기물이 더 많은 쪽
```

## 퍼즐 특화 고려사항

게임이 퍼즐 메커니즘 쪽으로 기울 경우:

### 일일 챌린지
- 매일 새로운 퍼즐
- 가장 빠른/최선의 해결을 위한 리더보드
- 주 동안 점진적으로 어려워지는 난이도

### 캠페인 모드
- 점점 어려워지는 퍼즐 시리즈
- 별점 등급 (성능에 따른 1-3점)
- 이전 퍼즐 완성으로 새 챌린지 잠금 해제

### 퍼즐 생성
- **수작업**: 보장된 품질, 제한된 수량
- **절차적**: 무한한 다양성, 일관성 없는 품질
- **하이브리드**: 수동 큐레이션이 포함된 절차적 생성

## 보드게임 특화 고려사항

게임이 보드게임 메커니즘 쪽으로 기울 경우:

### 보드 레이아웃
- **고정**: 매 게임 동일한 보드 (체스, 바둑)
- **가변**: 매번 다른 설정 (카탄)
- **절차적**: 무작위 생성
- **비대칭**: 각 플레이어마다 다름

### 전쟁의 안개?
- **완전 정보**: 전체 보드를 봄 (체스)
- **부분 정보**: 숨겨진 상대 기물 (스트라테고)
- **전쟁의 안개**: 제한된 시야 반경

**비동기 PvP의 경우**: 공정성을 위해 완전 정보 권장

## 진행 및 메타게임

### 플레이어 진행
- **랭킹/ELO**: 경쟁 래더
- **경험 레벨**: 코스메틱 명성
- **업적**: 특정 성취
- **통계**: 개인 최고 기록 추적

### 잠금 해제 (선택)
- **코스메틱**: 기물 스킨, 보드 테마
- **아바타**: 프로필 커스터마이징
- **칭호**: "그랜드마스터", "전술가" 등
- **게임 모드**: 플레이를 통해 변형 잠금 해제

**참고**: 진행을 의미 있게 유지하되 페이투윈은 없어야 함

## 접근성 고려사항

### 시각적 접근성
- **색맹**: 색상에만 의존하지 않기
- **대비**: 고대비 모드 옵션
- **텍스트 크기**: 확장 가능한 UI 요소
- **애니메이션**: 모션 감소 옵션

### 입력 접근성
- **키보드 탐색**: 마우스 없이 게임 전체 플레이 가능
- **터치 타겟**: 모바일에 충분한 크기 (최소 44x44px)
- **실수 취소/확인**: 실수로 인한 수 방지

### 인지적 접근성
- **튜토리얼**: 단계별 입문
- **도움말 시스템**: 게임 내 규칙 참조
- **수 힌트**: 학습을 위한 선택적 도움
- **저장/재개**: 진행 상황 잃지 않기

## 밸런스 고려사항

### 초기 밸런싱 접근법
1. **플레이테스팅**: 가장 중요한 도구
2. **분석**: 승률, 일반 전략 추적
3. **반복**: 정기적인 밸런스 업데이트
4. **커뮤니티 피드백**: 플레이어 의견 청취

### 추적할 지표
- **승률**: PvP에서 약 50%여야 함
- **선공 우위**: 너무 강하면 완화
- **인기 전략**: 지배적이면 너프
- **게임 길이**: 목표 시간과 일치해야 함
- **포기율**: 너무 높으면 게임이 너무 길거나 복잡한 것

### 밸런스 업데이트 전략
- **빈번한 소규모 조정** > 드문 대규모 개편
- 직감보다 **데이터 기반 결정**
- 밸런스 변경 **배포 전 테스트**
- 플레이어에게 **변경 사항 공지**

## 범위 관리

### MVP (최소 기능 제품)
첫 출시에 필수적인 것:
- ✅ 핵심 게임 규칙과 메커니즘
- ✅ 기본 AI와 싱글플레이어
- ✅ 비동기 PvP 매치메이킹
- ✅ 승패 기록
- ✅ 기본 튜토리얼

### 2단계
핵심 루프 검증 후 추가:
- 고급 AI 난이도
- 랭킹/ELO 시스템
- 게임 기록 및 리플레이
- 추가 게임 모드/변형

### 3단계
개선 및 확장:
- 업적
- 리더보드
- 소셜 기능
- 코스메틱 커스터마이징

## 구현 전 답해야 할 질문들

### 중요한 결정
1. **게임 보드 레이아웃은 어떻게 될 것인가?**
   - 그리드 크기? 형태? 특수 타일?

2. **기물과 그 규칙은 무엇인가?**
   - 몇 종류? 이동 규칙? 능력?

3. **정확한 승리 조건은 무엇인가?**
   - 주요 승리 조건? 무승부 해결?

4. **일반적인 게임은 얼마나 걸려야 하는가?**
   - 5분? 15분? 30분?

5. **스킬 천장은 어느 정도인가?**
   - 전략이 얼마나 깊어야 하는가?

6. **무작위성이 포함되는가?**
   - 주사위? 카드 뽑기? 완전 결정론적?

### 2차 결정
7. 게임당 플레이어 수는? (2명이 일반적)
8. 대칭 또는 비대칭 게임플레이?
9. 고정 또는 가변 시작 위치?
10. 다른 게임 모드가 있어야 하는가?

## 다음 단계

1. **핵심 메커니즘 프로토타입**: 게임 규칙의 가장 단순한 버전 제작
2. **플레이테스트**: 실제 플레이어와 테스트 (종이 프로토타입도 가능)
3. **반복**: 피드백을 바탕으로 규칙 개선
4. **구현**: 규칙이 확실해지면 디지털 버전 제작
5. **밸런싱**: 데이터를 사용하여 게임플레이 미세 조정

## 영감 및 참고자료

### 참고할 유사 게임
- **추상 전략**: 체스, 바둑, 체커
- **현대 보드게임**: 아줄, 하이브, 오니타마
- **퍼즐 게임**: 배는 바비, 테트리스, 스도쿠
- **디지털 턴제**: Into the Breach, Slay the Spire, Advance Wars

### 디자인 참고 자료
- 보드게임 메커니즘 연구를 위한 Board Game Geek (BGG)
- 게임 디자인 포럼과 커뮤니티
- 턴제 전략 게임 포스트모텀
- 게임 AI에 관한 학술 논문

---

**참고**: 이 문서는 프레임워크와 고려사항을 제공합니다. 구체적인 게임 메커니즘은 구현 전에 설계, 프로토타이핑 및 테스트되어야 합니다.
